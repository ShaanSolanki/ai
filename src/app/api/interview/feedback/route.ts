import { NextRequest, NextResponse } from "next/server";
import { connectDB } from "@/lib/db";
import InterviewSession from "@/models/interviewsession";
import Feedback from "@/models/feedback";

const GEMINI_API_KEY = "AIzaSyBEX6AXREH3YoelhWEA2oB4dKycuM_ykIs";
const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent`;

// TypeScript interfaces for clarity (optional but recommended)
interface FeedbackData {
  confidence?: number;
  correct?: boolean;
  accuracy?: number;
  explanation?: string;
  text?: string;
}

interface Question {
  _id: string;
  questionText: string;
  answerText?: string;
  feedback?: FeedbackData;
}

export async function POST(req: NextRequest) {
  try {
    await connectDB();
    const { sessionId } = await req.json();

    if (!sessionId) {
      return NextResponse.json({ error: "sessionId is required" }, { status: 400 });
    }

    const session = await InterviewSession.findById(sessionId);

    if (!session) {
      return NextResponse.json({ error: "Interview session not found" }, { status: 404 });
    }

    const questions = session.questions as Question[];
    const totalQuestions = questions.length;

    if (totalQuestions === 0) {
      return NextResponse.json({ error: "Session has no questions" }, { status: 400 });
    }

    const answeredQuestions = questions.filter(q => q.answerText && q.answerText.trim().length > 0).length;
    const correctAnswers = questions.filter(q => q.feedback?.correct).length;

    const averageConfidence = questions.reduce((sum, q) => sum + (q.feedback?.confidence ?? 0), 0) / totalQuestions;
    const averageAccuracy = questions.reduce((sum, q) => sum + (q.feedback?.accuracy ?? 0), 0) / totalQuestions;

    const feedbackPrompt = `
Given the following interview session data:
- Total Questions: ${totalQuestions}
- Answered Questions: ${answeredQuestions}
- Correct Answers: ${correctAnswers}
- Average Confidence: ${(averageConfidence * 100).toFixed(2)}%
- Average Accuracy: ${(averageAccuracy * 100).toFixed(2)}%

Please generate an overall feedback summary for the candidate's performance, highlighting strengths, areas for improvement, confidence levels, and general observations.
`.trim();

    const apiResponse = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: feedbackPrompt }] }],
      }),
    });

    if (!apiResponse.ok) {
      const errorBody = await apiResponse.text();
      console.error("Gemini API response error:", apiResponse.status, errorBody);
      return NextResponse.json({ error: "Failed to generate feedback from Gemini API" }, { status: 500 });
    }

    const data = await apiResponse.json();

    if (!data || !data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
      return NextResponse.json({ error: "Failed to generate feedback (no candidates)" }, { status: 500 });
    }

    const candidate = data.candidates[0];

    if (
      !candidate.content ||
      !candidate.content.parts ||
      !Array.isArray(candidate.content.parts) ||
      candidate.content.parts.length === 0
    ) {
      return NextResponse.json({ error: "Failed to generate feedback (no content parts)" }, { status: 500 });
    }

    const feedbackText = candidate.content.parts[0].text.trim();

    // Create new Feedback model instance and save
    const feedbackDoc = new Feedback({
      sessionId,
      text: feedbackText,
      confidence: averageConfidence,
      correct: correctAnswers === totalQuestions,
      accuracy: averageAccuracy,
      explanation: "Overall session feedback generated by Gemini API",
    });

    await feedbackDoc.save();

    return NextResponse.json({ feedback: feedbackDoc }, { status: 200 });
  } catch (err) {
    console.error("Error generating session feedback:", err);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}
